--▣ 접속된 사용자 확인
SELECT USER
FROM DUAL;
--==>>  HR

--▣ HR 계정 소유의 테이블 또는 뷰 목록 조회
SELECT *
FROM TAB;
/*

TNAME                          TABTYPE  CLUSTERID
------------------------------ ------- ----------
COUNTRIES                      TABLE             
DEPARTMENTS                    TABLE             
EMPLOYEES                      TABLE             
EMP_DETAILS_VIEW               VIEW              
JOBS                           TABLE             
JOB_HISTORY                    TABLE             
LOCATIONS                      TABLE             
REGIONS                        TABLE   
*/
-----------------------------------------------------------
--▣▣▣ 데이터베이스 정규화(Normalization)  ▣▣▣--
-- OOP: 나누고, 분리해서 설계
-- DB설계 단계에서 
-- 부모 자식 테이블 데이터 수 편차가 클수록 정규화를 시행하는 것이 바람직하다.

--○ 정규화란?
--- 한 마디로 DB 서버의 『메모리 낭비를 막기 위해』
--- 어떤 하나의 테이블을 ... 『식별자』를 가지는 여러 개의 테이블로
--- 나누는 과정을 말한다.

--  ex) 김한국이... 옥장판을 판매한다.
--       고객리스트 -> 거래처직원 명단이 적혀있는 수첩의 정보를
--        DB화 하려고 한다.

--     테이블명 : 거래처직원
/*
 10-Byte   10-Byte    10-Byte      10-Byte      10-Byte  10-Byte   10-Byte   
---------------------------------------------------------------------------
거래처회사명 회사주소     회사전화    거래처직원명  직급     이메일       휴대폰
---------------------------------------------------------------------------
   LG      서울여의도  02-3456-7890  김한0        부장  AAA@gmail.com  010-12...
   LG      서울여의도  02-3456-7890  김한1        과장  AAA@gmail.com  010-77...
   LG      서울여의도  02-3456-7890  김한2        대장  AAA@gmail.com  010-91...
   LG      서울여의도  02-3456-7890  김한3        부장  AAA@gmail.com  010-48...
   SK      서울소곡동  02-3456-7890  김한4        부장  AAA@gmail.com  010-55...
   LG      부산동래구  02-3456-7890  김한5        부장  AAA@gmail.com  010-66...
                                       ：       
                                       ：
---------------------------------------------------------------------------
*/

/*
    가정)  서울여의도 LG(본사)라는 회사에 근무하는 거래처 직원 명단이
           총 100만 명이라고 가정한다.
           (한 행(레코드)은 70-Byte이다.)
           
           어느 날.... 『서울여의도』 에 위치한 LG본사가
           『경기분당』으로 사옥을 이전하게 되었다.
           이로 인해...
           회사주소는 『경기분당』 으로 바꾸고
           전화번호는 『031-1111-2222』로 바뀌게 되었다
 
           그러면,... 100만 명의 회사주소와 회사전화를 변경해야 한다.

           - 이 때 수행되어야 하는 쿼리문 --> UPDATE 구문

           UPDATE 거래처지원
           SET 회사주소='경기분당', 회사전화='031-1111-2222'
           WHERE 거래처화사명 = 'LG'
             AND 회사주소 = '서울여의도'

          --> 100만 개 행을 하드디스크상에서 읽어다가
          메모리에 로드시켜 주어야 한다.
          즉, 100만 * 70Byte를 모두
          하드디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.

          --> 이는 테이블의 설계가 잘못되었으므로
          DB 서버는 조만간 메모리 고갈로 인해 DOWN될 것이다.

          --> 그러므로 이와 같은 상황을 막기 위해 정규화 과정을 수행해야 한다.
*/

-----------------------------------------------------------------------------
--▣ 제 1 정규화 (메모리 사용량을 줄일 수 있음)
---   어떤 하나의 테이블에 반복되어 컬럼 값들이 존재한다면
---   값들이 반복되어 나오는 컬럼을 분리하여
---   새로운 테이블을 만들어준다.

---->>    제 1 정규화를 수행하는 과정에서 분리된 테이블은
---        반드시 부모 테이블과 자식 테이블의 관계를 갖게 된다.

---->>  제 1 정규화를 수행하는 과정에서
----    부모 테이블의 PRIMARY KEY는
----    항상 자식 테이블의 FOREIGN KEY 로 전이된다.

----    부모 테이블 → 참조받는 컬럼 → PRIMARY KEY(제약조건) 
----    자식 테이블 → 참조하는 컬럼 → FOREIGN KEY(제약조건) 
----    
---->>  참조받는 컬럼이 갖는 특징(부모 테이블) → PRIMARY KEY(제약조건)
----    - 반드시 고유한 값(데이터)이 들어와야 한다.
----      즉, 중복된 값(데이터)이 없어야 한다.
----    - NULL 이어서는 안된다.(비어있어서는 안된다.)
----      즉, NOT NULL 이어야 한다.

---->>  참조하는 걸럼이 갖는 특징(자식 테이블) → FOREIGN KEY(제약조건) 
----     - 부모 테이블의 참조받는 컬럼이 갖는 데이터들 중
----       하나인 데이터를 참조해야 한다.


/*
 10-Byte   10-Byte    10-Byte        10-Byte      10-Byte  10-Byte   10-Byte   
---------------------------------------------------------------------------
거래처회사명 회사주소     회사전화     거래처직원명  직급     이메일       휴대폰
---------------------------------------------------------------------------
   LG      서울여의도  02-3456-7890  김한0        부장  AAA@gmail.com  010-12...
   LG      서울여의도  02-3456-7890  김한1        과장  AAA@gmail.com  010-77...
   LG      서울여의도  02-3456-7890  김한2        대장  AAA@gmail.com  010-91...
   LG      서울여의도  02-3456-7890  김한3        부장  AAA@gmail.com  010-48...
   SK      서울소곡동  02-3456-7890  김한4        부장  AAA@gmail.com  010-55...
   LG      부산동래구  02-3456-7890  김한5        부장  AAA@gmail.com  010-66...
                                       ：       


-- [테이블명 : 회사] → 부모 테이블
 10-Byte   10-Byte      10-Byte     10-Byte    
-------------------------------------------------------
 회사아이디  거래처회사명 회사주소     회사전화 
 ==========
 참조받는컬럼
-------------------------------------------------------
  10          LG      서울여의도  02-3456-7890
  20          SK      서울소곡동  02-3456-7890
  30          LG      부산동래구  02-3456-7890
                                             

-- [테이블명 : 직원] → 자식 테이블
 10-Byte      10-Byte  10-Byte   10-Byte   10-Byte   
-----------------------------------------------------------
   거래처직원명  직급     이메일     휴대폰   회사아이디
                                          ============
                                           참조하는 컬럼
-----------------------------------------------------------
 김한0        부장  AAA@gmail.com  010-12...     10
 김한1        과장  AAA@gmail.com  010-77...     10
 김한2        대장  AAA@gmail.com  010-91...     10
 김한3        부장  AAA@gmail.com  010-48...     10
 김한4        부장  AAA@gmail.com  010-55...     20
 김한5        부장  AAA@gmail.com  010-66...     30                                                                          ：
---------------------------------------------------------------------------
*/


--※ 테이블이 분할(분리)되기 이전 상태로 조회
/*
SELECT A.거래처회사명, A.회사주소, A.회사전화
      ,B.거래처직원명, B.직급, B.이메일, B.휴대폰
FROM 회사 A, 직원 B
WHERE A.회사아이디 = B.회사아이디;
*/
-- ==>> 원래의 상태로 조회하는데 이상 없음~!!!

/*
    가정)  서울여의도 LG(본사)라는 회사에 근무하는 거래처 직원 명단이
           총 100만 명이라고 가정한다.
        ------------------------------------------------------------
           어느 날.... 『서울여의도』 에 위치한 LG본사가
           『경기분당』으로 사옥을 이전하게 되었다.
           이로 인해...
           회사주소는 『경기분당』 으로 바꾸고
           전화번호는 『031-1111-2222』로 바뀌게 되었다
 
           그러면,... 회사 테이블에서 1건의 회사주소와 회사전화를 변경해야 한다.

           - 이 때 수행되어야 하는 쿼리문 --> UPDATE 구문

           UPDATE 회사
           SET 회사주소='경기분당', 회사전화='031-1111-2222'
           WHERE 회사아이디 = 10;

          --> 1 개 행을 하드디스크상에서 읽어다가
          메모리에 로드시켜 주어야 한다.
          즉, 1 * 40-Byte를 모두
          하드디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.

          --> 이는 테이블의 설계가 잘 된 상황이다.
            --> 정규화를 수행하기 이전에는 100만 건을 처리해야 했던 업무에서
                1건만 처리하면 되는 업무로 바뀐 상황이기 때문에
                DB서버는 메모리 고갈없이 아주 빠르게 처리될 것이다.
*/

-- A. 거래처회사명, 회사전화
/*
----------------------------------------------------------------------------
정규화 이후                           |     정규화 이전
----------------------------------------------------------------------------
SELECT 거래처회사명, 회사전화          |   SELECT 거래처회사명, 회사전화       
FROM 회사;                            |   FROM 거래처직원;
→  3 * 40-Byte                       |    →  200만 * 70-Byte
----------------------------------------------------------------------------
*/

-- A. 거래처직원명, 직급
/*
----------------------------------------------------------------------------
정규화 이후                            |     정규화 이전
----------------------------------------------------------------------------
SELECT 거래처직원명, 직급              |   SELECT 거래처직원명, 직급       
FROM 직원;                            |   FROM 거래처직원;
→  200만 * 50-Byte                    |    →  200만 * 70-Byte
----------------------------------------------------------------------------
*/

-- A. 거래처회사명, 거래처직원명
/*
----------------------------------------------------------------------------
정규화 이후                           |     정규화 이전
----------------------------------------------------------------------------
SELECT 거래처직원명, 직급              |   SELECT 거래처직원명, 직급       
FROM 회사 A JOIN 직원 B;              |    FROM 거래처직원;
ON A.회사아이디 = B.회사아이디         |   
→  (회사)     + (직원) Full scan      |  
→ (3*40-Byte) + ( 200만 * 50-Byte)    |    →  200만 * 70-Byte
----------------------------------------------------------------------------
*/



/*
-- 테이블 : 주문
-------------------------------------------------------------------------------
고객아이디              제품코드              주문일자              주문수량
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        P.K.
-------------------------------------------------------------------------------
CKS1124(김한국)        SWK5510(새우깡)      2025-07-05 11:11:11      10
CKJ0328(김한국2)       YPR8854(양파링)      2025-07-05 13:40:11      30
LCW4567(김한국3)       SWK5510(새우깡)      2025-07-05 10:22:30      20
LCW4567(김한국3)       KJK5821(감자깡)      2025-07-06 10:23:20      50
LYB6754(김한국4)       KJK5821(감자깡)      2025-07-07 15:09:20      10
                                    ：
                                    ：
-------------------------------------------------------------------------------
*/

--※  하나의 테이블에 존재하는 P.K 의 최대 갯수는 1개이다.
--    하지만, P.K.를 이루는(구성하는) 컬럼의 갯수는
--    복수(다수, 여러개)인 것이 가능하다.
--     컬럼 1개로만(단일컬럼) 구성된 P.K 를
--     Single P.K라고 부른다.( -> 단일 프라이머리 키)
--     두 개 이상의 컬럼으로 구성된  P.K 를
--     Composite P.K 라고 부른다. ( -> 복합 프라이머리 키)

------------------------------------------------------------------------------
--○ 제 2 정규화
-->  제 1 정규화를 마친 결과물에서 P.K가 Single Column 이라면
---- 제 2 정규화는 수행하지 않는다. --> 바로 3 정규화를 진행한다.
---- 하지만, P.K 가 Composite column이라면
---- 반드시 제 2 정규화를 수행해야 한다.

---->> 식별자가 아닌 컬럼은 식별자 전체 컬럼에 대해 의존적이어야 하는데
----   식별자 전체 컬럼이 아닌 일부 식별자 컬럼에 대해서 의존적이라면
----   이를 분리하여 새로운 테이블을 생성해준다.
--   --> 가급적 복합 PRIMARY KEY를 만들지 말라는 의미.....

/*
 --- 테이블명  : 과목  → 무모 테이블
 --------------------------------------------------------------------------------------------
 과목번호    과목명   교수자번호   교수자명          강의실코드     강의실설명
 ++++++++           +++++++++++
       (PRIMARTY KEY)
 --------------------------------------------------------------------------------------------
JAVA0101   자바기초      21        장영실               A403   전산실습관 4층 30석 규모
JAVA0102   자바중급      22        에디슨               T502   전자공학관 5층 20석 규모
DB1130     오라클중급    22        에디슨               A201   전산실습관 2층 80석 규모
DB1130     오라클중급    35        테슬라               T502   전자공학관 5층 20석 규모
DB1125     오라클고급    21        장영실               A203   전산실습관 2층 50석 규모
JSP3386     JSP심화     21        장영실               K101   인문사회관 1층 90석 규모
                                             ： 
                                             ： 

-- 과목번호가 바뀌면 과목명도 바뀐다. (과목명은 일부 식별자(과목번호)에 의존적이므로 테이블 분리가 적용)
-- 과목번호  ,  교수자번호 : 전체 식별자 
-- 과목번호 : 일부 식별자 
-- 교수자번호 : 일부 식별자 
 --------------------------------------------------------------------------------------------

 -- 테이블명 : 점수 → 자식 테이블
 --------------------------------------------------------------------------------------------
 과목번호        교수자번호     학번           학생명            점수
 +++++++++++++++++++++++++
          (F.K)
 --------------------------------------------------------------------------------------------
 DB1130             35       2505123         김한국              90
 DB1130             35       2505145         김한국2             98
 --------------------------------------------------------------------------------------------
*/


------------------------------------------------------------------------------
--○ 제 3 정규화
---> 식별자가 아닌 컬럼이 식별자가 아닌 컬럼에 의존적인 상황이라면 
--   이를 분리하여 새로운 테이블을 생성해 주어야 한다.
--   Ex.) 강의실코드, 강의실설명 컬럼..

--※ 관계(Relation)의 종류
--  1 : 1
-->  물리적으로 존재할 수 있는 관계이긴 하지만
--   피할 수 있으면 가급적 피해야 할 관계.

--  1 : 다(many) ★★★
-->  제 1정규화를 마친 결과물에서 대표적으로 나타나는 바람직한 관계.   
--   관계형 데이터베이스를 활용하는 과정에서 추구해야 하는 관계.


--  다(many) : 다(many)
-->  논리적인 모델링에서는 존재할 수 있지만
--   실재 물리적인 모델링에서 존재할 수 없는 관계.
------ 1 : 다(many) 로 분할을 시도...
/*


-- 테이블명 : 고객(다 → 1)                               
-------------------------------------------------
고객번호          고객명    이메일....
++++++++
  P.K
------------------------------------------------
1120            도우너      don@test.com
1123            마이콜      mic@naver.com
1136            또치      dc@naver.com
------------------------------------------------

-- 테이블명 : 제품(다 → 1)
--------------------------------------------------
 제품코드             제품명        제품단가
 +++++++++
  P.K
--------------------------------------------------
swk1123            새우깡             1500
cck4567            꼬깔콘             1200
jpc8517            자갈치              800
--------------------------------------------------

-- 테이블명 : 주문(다 → 다)
--------------------------------------------------
고객번호    제품코드         주문일자       주문수량
--------------------------------------------------
1120        swk1123          2025...        30
1120        jpc8517          2025...        20
1136        jpc8517          2025...        50

--------------------------------------------------

*/

------------------------------------------------------------------------------
--○ 제 4 정규화 ★★★
--- 위에서 확인한 내용과 같이  『다:다』 관계를  『1:다』 관계로 깨뜨리는 과정이
--- 제 4 정규화의 수행 과정이다.
---  →  일반적으로 파생 테이블 생성
---      →   『다:다』 관계를  『1:다』 관계로 깨뜨리는 역활 수행


------------------------------------------------------------------------------
--○ 역정규화(비정규화, 반정규화)  - 나눈 테이블을 합치는 과정
/*
▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
--▶ [A 경우]  →  역정규화를 수행하지 않는 것이 바람직한 상황~!!!!!
테이블명 : 부서                   테이블명 : 사원
10 BYTE  10 BYTE  10 BYTE      10 BYTE  10 BYTE  10 BYTE 10 BYTE 10 BYTE 10 BYTE          10 BYTE  
--------------------------      ----------------------------------------------------  +  ---------
부서번호  부서명     주소        사원번호  사원명   직급    급여     일사일   부서번호         부서명
++++++++                        +++++++                                  ==========
P.K                               P.K                                       F.K
-------------------            ----------------------------------------------------   +  ---------
     10개 행                           1,000,000 개 행
-------------------            ----------------------------------------------------   +  ---------

>>> 업무 분석 상 조회 결과물
-------------------------------------------------------
부서명      사원명(사원)    직급(사원)       급여(사원)
-------------------------------------------------------


-- 『부서』 테이블과 『사원』 테이블을 JOIN 했을 때의 크기
-- (10 * 30-Byte) + (1,000,000 * 60-Byte) = 300 + 60,000,000 = 60,000,300-Byte

-- 『사원』 테이블을 역정규화 수행한 후 이 테이블만 단독으로 읽어올 때의 크기
-- 1,000,000 * 70-Byte = 70,000,000-Byte

▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
--▶ [B 경우] →  역정규화를 수행하는 것이 바람직한 상황~!!!!
테이블명 : 부서                   테이블명 : 사원
10 BYTE  10 BYTE  10 BYTE      10 BYTE  10 BYTE  10 BYTE 10 BYTE 10 BYTE 10 BYTE          10 BYTE  
--------------------------      ----------------------------------------------------  +  ---------
부서번호  부서명     주소        사원번호  사원명   직급    급여     일사일   부서번호         부서명
++++++++                        +++++++                                  ==========
P.K                               P.K                                       F.K
-------------------            ----------------------------------------------------   +  ---------
     500,000개 행                           1,000,000 개 행
-------------------            ----------------------------------------------------   +  ---------

>>> 업무 분석 상 조회 결과물
-------------------------------------------------------
부서명      사원명(사원)    직급(사원)       급여(사원)
-------------------------------------------------------


-- 『부서』 테이블과 『사원』 테이블을 JOIN 했을 때의 크기
-- (500,000 * 30-Byte) + (1,000,000 * 60-Byte) = 15,000,000 + 60,000,000 = 75,000,000-Byte

-- 『사원』 테이블을 역정규화 수행한 후 이 테이블만 단독으로 읽어올 때의 크기
-- 1,000,000 * 70-Byte = 70,000,000-Byte
*/


/*
테이블명 : 사원 → 부모 테이블
-----------------------------------------------------------------------------
사원번호     사원명        주민번호        입사일         급여   ▶ 직급 ◀
+++++++++
  P.K
-----------------------------------------------------------------------------
7369         김한국       00....          2020-         .....     부장
7370         김한국2      00....          2020-         .....     차장
7371         김한국3      01....          2022-         .....     과장
7372         김한국4      01....          2022-         .....     대리
7373         김한국5      97....          2015-         .....     차장
7374         김한국5      04....          2023-         .....     대리
-----------------------------------------------------------------------------


테이블명 : 사원가족 →  자식 테이블
---------------------------------------------------------------------
주민번호       사원번호           ▶ 관계 ◀            성명
 ++++++++    =========
   P.K          F.K
---------------------------------------------------------------------
05....          7369                아내              승희
05....          7370                아내              카리나
25....          7370                아들              유혜진
06....          7371                아내              윤아
95....          7372                남편              김선호
---------------------------------------------------------------------

▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
==>>> 문제점
--▶▶▶  관계 ---> 관계코드
-- 테이블명 : 관계
-------------------------------------
관계코드         관계명
-------------------------------------
    1           배우자(아내/남편)
    2           자녀
    3           부모
-------------------------------------

▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
==>>> 문제점
--▶▶▶  직급 ---> 직급코드
-- 테이블명 : 직급
-------------------------------------
직급코드         직급명
-------------------------------------
    1           사원
    2           대리, 주임
    3           과장, 실장
    4           차장, 팀장
-------------------------------------
*/


--> 1. 예측 가능한 데이터가 입력되는 상황이라면.... → 코드화~!!!(제 1 정규화)
--  2. 기존 컬럼을 통해 얻어낼 수 있는 데이터라면...  → 컬럼으로 구성하지 않는다~!!!
--     ---------------
--        쿼리로 
--          Ex) 컬럼('나이') X  → 해마다 업데이트 필요
--          Ex) 컬럼('포인트' 점수로 등급산정) X  → 포인트 변경에 따라 업데이트 필요

/*
--※ 참고
   1. 관계(relationship, relation)
     - 모든 엔트리(entry)는 단일값을 가진다.
     - 각 열(column)은 유일한 이름을 가지며 순서는 무의미하다.
     - 테이블의 모든 행(row = 튜플 = tuple) 은 동일하지 않으며 순서는 무의미하다.

    2. 속성(attribute)
     - 테이블의 열(column)을 나타낸다.
     - 자료의 이름을 가진 최소 논리적 단위 : 객체의 성질, 상태 기술
     - 일반 파일(file)의 항목(아이템 = item = 필드 = field)에 해당한다.
     - 엔티티(entity)의 특성과 상태를 기술
     - 속성(attribute)의 이름은 모두 달라야 한다.

     3. 튜플 = tuple = 엔티티 = entity
     - 테이블의 행(row)
     - 연관된 몇 개의 속성(attrubute)으로 구성
     - 개념 정보의 단위
     - 일반 파일(file)의 레코드(record)에 해당한다.
     - 튜플 변수(tuple variable) : 튜플(tuple)을 가리키는 변수, 모든 튜블 집합을 도메인으로 하는 변수

     4. 도메인(domain)
     - 각 속성(attribute)이 가질 수 있도록 허용된 값들의 집합
     - 속성 명과 도메인 명이 반드시 동일할 필요는 없음
     - 모든 릴레이션에서 모든 속성들의 도메인은 원자적(atomic)이어야 함.
     - 원자적 도메인 : 도메인의 원소가 더 이상 나누어질 수 없는 단일체일 때를 나타냄.

     5. 릴레이션(relation)
     - 파일 시스템에서 파일(file)과 같은 개념
     - 중복된 튜플(tuple = entity = 엔티티)을 포함하지 않는다. → 모두 사이함(튜플의 유일성)
     - 릴레이션 = 튜플(엔티티 = entity)이 집합. 따라서 튜플의 순서는 무의미하다.
     - 속성(attribute) 간에는 순서가 없다.
*/

----------------------------------------------------------------------------------------------

--▣▣▣  무결성(Integrity)  ▣▣▣---
/*
1. 무결성에는 개체 무결성(Entity Integrity)
             참조 무결성(Relational Integrity)
             도메인 무결성(Domain Integrity)이 있다.

2. 개체 무결성(Entity Integrity)
   개체 무결성은 릴레이션에서 저장되는 튜플(tuple)의
   유일성을 보장하기 위한 제약조건이다.

3. 참조 무결성(Relational Integrity)
   참조 무결성은 릴레이션 간의 데이터 일관성을 
   보장하기 위한 제약조건이다.

4. 도메인 무결성(Domain Integrity)
   도메인 무결성은 허용 가능한 값의 범위를
   지정하기 위한 제약조건이다. (데이터 타입과 연관...)

5. 제약조건의 종류
  - PRIMARY KEY(PK:P) → 부모 테이블의 참조받는 컬럼 → 기본키, 식별자
    해당 컬럼의 값은 반드시 존재해야 하며, 유일해야 한다. (중복x)
    (UNIQUE 와 NOT NULL 이 결합된 형태), 테이블당 1개만 지정 가능

  - FOREIGN KEY(FK:F:R) → 자식 테이블의 참조하는 컬럼 → 외래키, 외부키, 참조키
    해당 컬럼의 값은 참조되는 테이블의 컬럼 데이터들 중 하나와
    일치하거나 NULL을 가진다.

  - UNIQUE(UK:U)
    테이블 내에서 해당 컬럼의 값은 항상 유일해야 한다.
      ------------------------------------------------------
      회원번호       주민번호       전화번호         
      ++++++++      --------       -------
        P.K           UNIQUE        UNIQUE
      ------------------------------------------------------

  - NOT NULL(NN:CK:C)
    해당 컬럼은 NULL을 포함 할 수 없다. (비어있어서는 안된다.)
    - 필수 입력정보...

  - CKECK(CK:C)
    해당 컬럼에서 저장 가능한 데이터의 값의 범위나 조건을 지정한다.

*/


-- ### --▣ --※ --○ ★ 『』 ? ▣ ◀▶ ▼ ▲ ⓐ ⓑ ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩  →   ←  ↓  …  ： º↑ /* */  ─ ┃ ┛┯ ┐┘ ￦
--/*▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼*/
--/*================[ 7월 XX일(금) ]========================*/

-----------------[ 강사님 풀이 - START ] ------------------------------
-----------------[  강사님 풀이 - END  ] ------------------------------

-----------------[ 실습 - START ] ----------------------------
-----------------[  실습 - END  ] ----------------------------
